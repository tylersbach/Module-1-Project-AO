<!DOCTYPE html>
<html lang="en">

<head>
  <title>Advanced Objects</title>
</head>

<body>
  <h1>Advanced Objects</h1>
  <p>Please load this file in VSCode and Chrome, and open the Console in Chrome Dev Tools.</p>
  <p>Work through the challenges found inside the script tag in this document,
    until the Console reports all tests passing.</p>

  <script>
    // In CHALLENGES 1-4 you will flesh out some classes.

    // To do this, translate each ğŸ§  set of instructions into a working class.
    // â— Classes are scaffolded for you.
    // â— Watch the Guided Project to learn proper debugging technique.

    // ğŸ‘‰ CHALLENGE 1
    // ğŸ§  Build a PeterPan class. This class allows to instantiate persons with Peter Pan syndrome.
    // ğŸ§  When instantiating a new person using this class, we provide a string with the name of the person.
    // ğŸ§  The new person will have a `name` prop initialised to the desired name, and an `age` prop initialised to 0.
    // ğŸ§  The person also has an `ageGracefully` method, which increases `age` by 1 each time it's called.
    // ğŸ§  But there's a catch: once `age` reaches 12, the `ageGracefully` method will have no effect.
    class PeterPan { 
      constructor (name) {
this.name = name
this.age = 0
      }
      ageGracefully() {
        if (this.age < 12) {
          this.age++
        }
      }

    }

    // ğŸ‘‰ CHALLENGE 2
    // ğŸ§  Build an AirPlane class. This class allows to instantiate airplanes.
    // ğŸ§  When instantiating a new plane using this class, we provide a string with the model of the plane.
    // ğŸ§  A new plane has a `model` prop initialised to the desired model, and also an `altitude` prop initialised to 0.
    // ğŸ§  Planes have an `up` method, which takes a number of meters as its argument.
    // ğŸ§  Calling `up` changes the `altitude` prop appropriately and returns the updated `altitude`.
    // ğŸ§  Planes have a `down` method, which takes a number of meters as its argument.
    // ğŸ§  Calling `down` changes the `altitude` prop appropriately and returns the updated `altitude`.
    // ğŸ§  If calling `down` would cause the plane to go below altitude zero, `altitude` is set to 0 and the string "CRASH!" is returned.
    class AirPlane {
constructor(model) {
  this.model = model
  this.altitude = 0
}
up(meters) {
  this.altitude += meters
  return this.altitude
}
down(meters) {
  if (this.altitude >= meters) {
    this.altitude -= meters
    return this.altitude
  }
  this.altitude = 0
  return "CRASH!"
}
    }

    // ğŸ‘‰ CHALLENGE 3
    // ğŸ§  Build a Bulb class.
    // ğŸ§  All new bulbs are initialised with a prop `isOn` and three methods: `turnOn`, `turnOff` and `toggle`.
    // ğŸ§  The initial value of `isOn` will be the Boolean false.
    // ğŸ§  The methods work as one might expect, changing the value of `isOn` to the appropriate Boolean.
    // ğŸ§  The methods also return one of these two strings: "You turned the bulb ON", or "You turned the bulb OFF".
    class Bulb {
isOn = false
turnOn() {
  this.isOn = true
  return "You turned the bulb ON"
}
turnOff () {
  this.isOn = false
  return "You turned the bulb OFF"
}
toggle() {
  this.isOn = !this.isOn
  if (this.isOn) {
    return "You turned the bulb ON"
  }
  return "You turned the bulb OFF"
}
    }

    // ğŸ‘‰ CHALLENGE 4
    // ğŸ§  Build a CountDown class that can count down starting at any number we pass to the constructor.
    // ğŸ§  CountDowns have a `count` method that returns a string in the format "10!".
    // ğŸ§  One exception is that upon reaching zero, instead of returning "0!", `count` returns "Liftoff!"
    // ğŸ§  After liftoff, `count` returns null instead of a string.
    // ğŸ§  It's up to you to decide what property (or properties) are needed.
    // Example of use:
    //   let minusThree = new CountDown(3) // we could pass any number
    //   minusThree.count() // returns "3!"
    //   minusThree.count() // returns "2!"
    //   minusThree.count() // returns "1!"
    //   minusThree.count() // returns "Liftoff!"
    //   minusThree.count() // returns null
    //   minusThree.count() // returns null
    class CountDown {
  constructor(num) {
    this.currentNum = num
  }
  count() {
    if (this.currentNum >= 1) {
      const oldValue = this.currentNum
      this.currentNum--
      return '${oldValue}!'
    } else if (this.currentNum === 0) {
      this.currentNum--
      return "Lifeoff!"
    } else {
      return null 
    }
  }
}
    

    // ğŸ§ª TESTS, do not work below this line
    // ğŸ§ª TESTS, do not work below this line
    // ğŸ§ª TESTS, do not work below this line
    {
      runTest('CHALLENGE 1 - PeterPan', [
        function () {
          let actual, description = 'The person ages normally until age 12'
          let expected = { name: 'Joe', age: 12 }
          try {
            actual = new PeterPan('Joe');
            [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].forEach(round => actual.ageGracefully())
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'The person does not age beyond 12 years old'
          let expected = { name: 'Joe', age: 12 }
          try {
            actual = new PeterPan('Joe');
            [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14].forEach(round => actual.ageGracefully())
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        }
      ])
      runTest('CHALLENGE 2 - Airplane', [
        function () {
          let actual, description = 'New plane has model and altitude properties'
          let expected = { model: 'Spitfire', altitude: 0 }
          try {
            actual = new AirPlane('Spitfire')
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'New plane has an up method that increases altitude'
          let expected = { model: 'Spitfire', altitude: 10 }
          try {
            actual = new AirPlane('Spitfire')
            actual.up(4)
            actual.up(6)
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'The up method returns the updated altitude'
          let expected = 10
          try {
            let plane = new AirPlane('Spitfire')
            plane.up(4)
            actual = plane.up(6)
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'New plane has a down method that decreases altitude'
          let expected = 7
          try {
            let plane = new AirPlane('Spitfire')
            plane.altitude = 10
            plane.down(3)
            actual = plane.altitude
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'The down method returns the updated altitude'
          let expected = 8
          try {
            let plane = new AirPlane('Spitfire')
            plane.altitude = 11
            actual = plane.down(3)
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'A crashed plane has altitude 0'
          let expected = 0
          try {
            let plane = new AirPlane('Spitfire')
            plane.altitude = 10
            plane.down(11)
            actual = plane.altitude
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'The down method returns CRASH! if we crash the plane'
          let expected = "CRASH!"
          try {
            let plane = new AirPlane('Spitfire')
            plane.altitude = 10
            actual = plane.down(11)
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
      ])
      runTest('CHALLENGE 3 - Bulb', [
        function () {
          let actual, description = 'New bulbs have an isOn property with a value of false'
          let expected = { isOn: false }
          try {
            actual = new Bulb()
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'A new bulb can be turned on'
          let expected = { isOn: true }
          try {
            actual = new Bulb()
            actual.turnOn()
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'Turning on a bulb returns the right string'
          let expected = "You turned the bulb ON"
          try {
            let bulb = new Bulb()
            actual = bulb.turnOn()
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'A bulb that is on can be turned off'
          let expected = { isOn: false }
          try {
            actual = new Bulb()
            actual.isOn = true
            actual.turnOff()
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'Turning off a bulb returns the right string'
          let expected = "You turned the bulb OFF"
          try {
            let bulb = new Bulb()
            bulb.isOn = true
            actual = bulb.turnOff()
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'An off bulb can be toggled on'
          let expected = { isOn: true }
          try {
            actual = new Bulb()
            actual.toggle()
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'An on bulb can be toggled off'
          let expected = { isOn: false }
          try {
            actual = new Bulb()
            actual.isOn = true
            actual.toggle()
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'Toggling multiple times works as expected'
          let expected = [true, false, true]
          try {
            let bulb = new Bulb()
            actual = []
            bulb.toggle()
            actual.push(bulb.isOn)
            bulb.toggle()
            actual.push(bulb.isOn)
            bulb.toggle()
            actual.push(bulb.isOn)
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'Toggling returns the proper messages'
          let expected = ["You turned the bulb ON", "You turned the bulb OFF", "You turned the bulb ON"]
          try {
            let bulb = new Bulb()
            actual = []
            actual.push(bulb.toggle())
            actual.push(bulb.toggle())
            actual.push(bulb.toggle())
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
      ])
      runTest('CHALLENGE 4 - CountDown', [
        function () {
          let actual, description = 'Calling count returns the proper number'
          let expected = ["4!", "3!", "2!", "1!"]
          try {
            let minusFour = new CountDown(4)
            actual = []
            actual.push(minusFour.count())
            actual.push(minusFour.count())
            actual.push(minusFour.count())
            actual.push(minusFour.count())
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'Upon reaching zero, count returns Liftoff!'
          let expected = ["3!", "2!", "1!", "Liftoff!"]
          try {
            let minusThree = new CountDown(3)
            actual = []
            actual.push(minusThree.count())
            actual.push(minusThree.count())
            actual.push(minusThree.count())
            actual.push(minusThree.count())
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
        function () {
          let actual, description = 'After liftoff, count always returns null'
          let expected = ["2!", "1!", "Liftoff!", null, null]
          try {
            let minusTwo = new CountDown(2)
            actual = []
            actual.push(minusTwo.count())
            actual.push(minusTwo.count())
            actual.push(minusTwo.count())
            actual.push(minusTwo.count())
            actual.push(minusTwo.count())
          } catch (err) { actual = err.message }
          return [description, expected, actual]
        },
      ])
      function runTest(testTitle, tests) {
        console.log(testTitle)
        tests.forEach((test, idx) => {
          const [description, expected, actual] = test().map(JSON.stringify)
          if (expected === actual) {
            console.log(`\tâœ… Test ${idx + 1} ${description} PASSED`)
          } else {
            console.log(`\tâŒ Test ${idx + 1} ${description} FAILED:
          ğŸ’€ Expected ${expected} but got ${actual}`)
          }
        })
      }
    }
  </script>
</body>

</html>
